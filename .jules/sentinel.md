## 2024-05-23 - Session ID Input Validation
**Vulnerability:** The `Manager.Get` method previously passed the raw session ID from the cookie directly to the backend store. While the SQLite store uses parameterized queries (preventing SQL injection), other stores or future implementations might be vulnerable to injection or DoS attacks if invalid inputs (e.g., extremely long strings or control characters) are processed.
**Learning:** Defense in depth is crucial. Even if the backend is secure, validating input at the boundary prevents unnecessary processing and potential exploit vectors.
**Prevention:** Added strict validation in `Manager.Get` to ensure the session ID matches the expected format (32 lowercase hex characters) before querying the store. Invalid IDs are treated as missing sessions (returning a new session).

## 2024-05-23 - Fail-Safe Session Destruction
**Vulnerability:** The `Manager.Destroy` method previously attempted to delete the session from the backend store before invalidating the client-side cookie. If the store operation failed (e.g., database downtime), the function would return an error early, leaving the valid session cookie on the user's browser. This created a "zombie session" state where the user believed they were logged out, but their credentials remained active on the client.
**Learning:** Security operations should "fail safe" (or "fail closed" for access, "fail open" for logout). When destroying a session, priority must be given to invalidating the client's token, as this is the user's primary interface with the session state. Backend inconsistencies can be reconciled later (TTL expiration), but a client retaining a token they intended to destroy is a security usability failure.
**Prevention:** Reordered operations in `Manager.Destroy` to unconditionally clear the cookie (set expiration to past) before attempting backend deletion. The error from the backend is still returned for logging/alerting, but the user is effectively logged out.

## 2024-05-23 - Max Session Size Limit (DoS Protection)
**Vulnerability:** The session manager previously had no limit on the size of data that could be stored in a session. This allowed a potential Denial of Service (DoS) attack where an attacker (or a bug) could stuff large amounts of data into a session, causing excessive memory usage during serialization or exhausting backend storage.
**Learning:** Always enforce upper bounds on user-controlled input sizes, even for internal structures like session data. Unbounded growth is a classic resource exhaustion vector.
**Prevention:** Introduced `MaxSessionBytes` configuration option (defaulting to unlimited for compatibility). The `Manager.Save` method now preemptively serializes session data to a temporary buffer to verify its size before attempting to save it to the store. If the limit is exceeded, it returns `ErrSessionTooLarge`.
